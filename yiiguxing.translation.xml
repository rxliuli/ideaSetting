<application>
  <component name="AppStorage">
    <histories>
      <item value="Rx Prompt" />
      <item value="Variable" />
      <item value="Unresolved" />
      <item value="JS Unresolved Variable" />
      <item value="confirm Add Base Customer" />
      <item value="confirm Add Base Consumer" />
      <item value="confirm Add Base Costomer" />
      <item value="confirm Add Base Constomer" />
      <item value="confirm" />
      <item value="config" />
      <item value="checked Service Content" />
      <item value="checkbox Service Content" />
      <item value="checkboxservice Content" />
      <item value="Base Houses Hold Info" />
      <item value="is being wrapped as a Thymeleaf 3 fragment expression (~{...}) for backwards compatibility purposes. This wrapping will be dropped in the next major version of the expression processor, so please rewrite as a Thymeleaf 3 fragment expression to future-proof your code. See https://github.com/thymeleaf/thymeleaf/issues/451 for more information." />
      <item value="update Customer" />
      <item value="set Table Fill List" />
      <item value="unit Name" />
      <item value="READ DATE TIMESTAMPS AS NANOSECONDS" />
      <item value="Feature that determines whether encountering of unknown * properties (ones that do not map to a property, and there is * no &quot;any setter&quot; or handler that can handle it) * should result in a failure (by throwing a * {@link JsonMappingException}) or not. * This setting only takes effect after all other handling * methods for unknown properties have been tried, and * property remains unhandled. *&lt;p&gt; * Feature is enabled by default (meaning that a * {@link JsonMappingException} will be thrown if an unknown property * is encountered). */" />
      <item value="Note that support for this feature is implemented by individual data format * module, if (and only if) it makes sense for the format in question. For JSON, * for example, this feature has no effect as properties need not be pre-defined. *&lt;p&gt; * Feature is disabled by default, meaning that if the underlying data format * requires knowledge of all properties to output, attempts to read an unknown * property will result in a {@link JsonProcessingException}" />
      <item value="Feature that determines what to do if the underlying data format requires knowledge * of all properties to decode (usually via a Schema), and if no definition is * found for a property that input content contains. * Typically most textual data formats do NOT require schema information (although * some do, such as CSV), whereas many binary data formats do require definitions * (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not). * Further note that some formats that do require schema information will not be able * to ignore undefined properties: for example, Avro is fully positional and there is * no possibility of undefined data. This leaves formats like Protobuf that have identifiers * that may or may not map; and as such Protobuf format does make use of this feature. *&lt;p&gt;" />
      <item value="Typically most textual data formats do NOT require schema information (although * some do, such as CSV), whereas many binary data formats do require definitions * (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not). *&lt;p&gt; * Note that support for this feature is implemented by individual data format * module, if (and only if) it makes sense for the format in question. For JSON, * for example, this feature has no effect as properties need not be pre-defined. *&lt;p&gt; * Feature is disabled by default, meaning that if the underlying data format * requires knowledge of all properties to output, attempts to write an unknown * property will result in a {@link JsonProcessingException}" />
      <item value="Feature that determines what to do if the underlying data format requires knowledge * of all properties to output, and if no definition is found for a property that * caller tries to write. If enabled, such properties will be quietly ignored; * if disabled, a {@link JsonProcessingException} will be thrown to indicate the * problem." />
      <item value="IGNORE UNKNOWN" />
      <item value="IGNORE UNDEFINED" />
      <item value="Invocation of init method failed; nested exception is java.lang.IllegalStateException: Ambiguous mapping. Cannot map 'baseHouseInfoController' method" />
      <item value="pronum" />
      <item value="num" />
      <item value="pro" />
      <item value="modicon list" />
      <item value="midicon" />
      <item value="midicon list" />
      <item value="tlt" />
      <item value="main" />
      <item value="maintlt" />
      <item value="sectiontitle" />
      <item value="container" />
      <item value="containter" />
      <item value="summary Statistics" />
      <item value="parallel" />
      <item value="com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;pages&quot; (class com.baomidou.mybatisplus.plugins.Page), not marked as ignorable (4 known properties: &quot;size&quot;, &quot;records&quot;, &quot;total&quot;, &quot;current&quot;])" />
      <item value="java.lang.AssertionError: No value at JSON path &quot;$.data.data&quot;" />
      <item value="依赖注入" />
      <item value="If this object represents a primitive type or void, the method * returns an array of length 0." />
      <item value="&lt;p&gt; If this {@code Class} object represents an array type, the * interfaces {@code Cloneable} and {@code java.io.Serializable} are * returned in that order. *" />
      <item value="* * &lt;p&gt; If this object represents a class, the return value is an array * containing objects representing all interfaces implemented by the * class. The order of the interface objects in the array corresponds to * the order of the interface names in the {@code implements} clause * of the declaration of the class represented by this object. For * example, given the declaration: * &lt;blockquote&gt;" />
      <item value="&lt;p&gt;If the superclass is a parameterized type, the {@code Type} * object returned must accurately reflect the actual type * parameters used in the source code. The parameterized type * representing the superclass is created if it had not been * created before. See the declaration of {@link * java.lang.reflect.ParameterizedType ParameterizedType} for the * semantics of the creation process for parameterized types. If * this {@code Class} represents either the {@code Object} * class, an interface, a primitive type, or void, then null is * returned. If this object represents an array class then the * {@code Class} object representing the {@code Object} class is * returned." />
      <item value="Returns the {@code Type} representing the direct superclass of * the entity (class, interface, primitive type or void) represented by * this {@code Class}." />
      <item value="Returns the {@code Class} representing the superclass of the entity * (class, interface, primitive type or void) represented by this * {@code Class}. If this {@code Class} represents either the * {@code Object} class, an interface, a primitive type, or void, then * null is returned. If this object represents an array class then the * {@code Class} object representing the {@code Object} class is" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1016" />
        <entry key="ENGLISH" value="1017" />
        <entry key="IRISH" value="2" />
        <entry key="BULGARIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="GALICIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CZECH" value="1" />
        <entry key="CORSICAN" value="20" />
        <entry key="KURDISH" value="1" />
        <entry key="LATIN" value="5" />
        <entry key="LATVIAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALAGASY" value="3" />
        <entry key="PORTUGUESE" value="3" />
        <entry key="JAPANESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="SLOVAK" value="1" />
        <entry key="SLOVENIAN" value="2" />
        <entry key="CEBUANO" value="1" />
        <entry key="GREEK" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>