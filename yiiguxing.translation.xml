<application>
  <component name="AppStorage">
    <histories>
      <item value="await Termination" />
      <item value="condition" />
      <item value="条件" />
      <item value="get Delay" />
      <item value="when Complete Async" />
      <item value="distinct" />
      <item value="Incorporate a new double value using Kahan summation / * compensation summation." />
      <item value="sum With Compensation" />
      <item value="summarizing Double" />
      <item value="summarizing Int" />
      <item value="Returns a {@code Collector} which applies an {@code int}-producing * mapping function to each input element, and returns summary statistics * for the resulting values." />
      <item value="Returns a {@code Collector} which partitions the input elements according * to a {@code Predicate}, and organizes them into a * {@code Map&lt;Boolean, List&lt;T&gt;&gt;}." />
      <item value="partitioning By" />
      <item value="grouping By Concurrent" />
      <item value="box Supplier" />
      <item value="averaging Int" />
      <item value="compute Final Sum" />
      <item value="Compensation" />
      <item value="double tmp = value - intermediateSum[1]; double sum = intermediateSum[0]; double velvel = sum + tmp; // Little wolf of rounding error intermediateSum[1] = (velvel - sum) - tmp; intermediateSum[0] = velvel; return intermediateSum;" />
      <item value="High-order bits of the sum are in intermediateSum[0], low-order * bits of the sum are in intermediateSum[1], any additional * elements are application-specific." />
      <item value="igh-order bits of the sum are in intermediateSum[0], low-order * bits of the sum are in intermediateSum[1], any additional * elements are application-specific." />
      <item value="summing Int" />
      <item value="counting" />
      <item value="unmodifiable List" />
      <item value="Adapts a {@code Collector} to perform an additional finishing * transformation. For example, one could adapt the {@link #toList()} * collector to always produce an immutable list with: * &lt;pre&gt;{@code * List&lt;String&gt; people * = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));" />
      <item value="type of elements accepted by downstream collector" />
      <item value="the type of the input elements" />
      <item value="Adapts a {@code Collector} accepting elements of type {@code U} to one * accepting elements of type {@code T} by applying a mapping function to * each input element before accumulation." />
      <item value="{@code BinaryOperator&lt;Map&gt;} that merges the contents of its right * argument into its left argument, using the provided merge function to * handle duplicate keys." />
      <item value="Returns a {@code Collector} that accumulates the input elements into a * new {@code Collection}, in encounter order. The {@code Collection} is * created by the provided factory." />
      <item value="casting Identity" />
      <item value="* Returns a merge function, suitable for use in * {@link Map#merge(Object, Object, BiFunction) Map.merge()} or * {@link #toMap(Function, Function, BinaryOperator) toMap()}, which always * throws {@code IllegalStateException}. This can be used to enforce the * assumption that the elements being collected are distinct. *" />
      <item value="Returns a merge function, suitable for use in * {@link Map#merge(Object, Object, BiFunction) Map.merge()} or * {@link #toMap(Function, Function, BinaryOperator) toMap()}, which always * throws {@code IllegalStateException}. This can be used to enforce the * assumption that the elements being collected are distinct." />
      <item value="throwing Merger" />
      <item value="Returns an equivalent stream that is parallel. May return * itself, either because the stream was already parallel, or because * the underlying stream state was modified to be parallel." />
      <item value="parallel" />
      <item value="Caused by: org.apache.ibatis.reflection.ReflectionException: Could not set property 'id' of 'class com.zx.idc.ds.base.cus.entity.BaseCustomer' with value '1090194151883444226' Cause: java.lang.IllegalArgumentException: argument type mismatch" />
      <item value="with value '1090194151883444226' Cause: java.lang.IllegalArgumentException: argument type mismatch" />
      <item value="Illegal Argument Exception" />
      <item value="Unsatisfied dependency expressed through field 'base'; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'java.lang.Object' available: expected single matching bean but found 3: systemEnvironment,contextParameters,contextAttributes" />
      <item value="java.lang.NoSuchMethodError: org.yaml.snakeyaml.LoaderOptions.setAllowDuplicateKeys" />
      <item value="Caused by: java.lang.IllegalStateException: SpringJUnit4ClassRunner requires JUnit 4.12 or higher." />
      <item value="java.lang.IllegalArgumentException: Cannot instantiate factory class: org.springframework.boot.test.context.DefaultTestExecutionListenersPostProcessor" />
      <item value="camel To Underline" />
      <item value="underline To Camel 2" />
      <item value="Sys Domain Category" />
      <item value="Sys Domain Catetry" />
      <item value="Sys Domain Catetory" />
      <item value="slabel" />
      <item value="permission" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="235" />
        <entry key="ENGLISH" value="236" />
        <entry key="FRENCH" value="1" />
        <entry key="GALICIAN" value="1" />
        <entry key="CORSICAN" value="20" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="JAPANESE" value="2" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="GREEK" value="1" />
      </map>
    </option>
  </component>
</application>