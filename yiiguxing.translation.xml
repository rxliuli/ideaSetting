<application>
  <component name="AppStorage">
    <histories>
      <item value="Connection reset" />
      <item value="Returns an infinite sequential ordered {@code Stream} produced by iterative * application of a function {@code f} to an initial element {@code seed}, * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)}, * {@code f(f(seed))}, etc." />
      <item value="Returns an infinite sequential unordered stream where each element is * generated by the provided {@code Supplier}. This is suitable for * generating constant streams, streams of random elements, etc." />
      <item value="The behavior of this operation is explicitly nondeterministic; it is * free to select any element in the stream. This is to allow for maximal * performance in parallel operations; the cost is that multiple invocations * on the same source may not return the same result. (If a stable result * is desired, use {@link #findFirst()} instead.)" />
      <item value="Returns an {@link Optional} describing some element of the stream, or an * empty {@code Optional} if the stream is empty." />
      <item value="Returns an {@link Optional} describing the first element of this stream, * or an empty {@code Optional} if the stream is empty. If the stream has * no encounter order, then any element may be returned." />
      <item value="Returns whether no elements of this stream match the provided predicate. * May not evaluate the predicate on all elements if not necessary for * determining the result. If the stream is empty then {@code true} is * returned and the predicate is not evaluated. *" />
      <item value="This method evaluates the &lt;em&gt;universal quantification&lt;/em&gt; of the * negated predicate over the elements of the stream (for all x ~P(x)). If * the stream is empty, the quantification is said to be vacuously satisfied * and is always {@code true}, regardless of P(x)." />
      <item value="This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;short-circuiting * terminal operation" />
      <item value="none" />
      <item value="Returns whether no elements of this stream match the provided predicate. * May not evaluate the predicate on all elements if not necessary for * determining the result. If the stream is empty then {@code true} is * returned and the predicate is not evaluated." />
      <item value="none Match" />
      <item value="the result type of the reduction operation" />
      <item value="the mutable accumulation type of the reduction operation (often * hidden as an implementation detail)" />
      <item value="the type of input elements to the reduction operation" />
      <item value="Performs a &lt;a href=&quot;package-summary.html#MutableReduction&quot;&gt;mutable * reduction&lt;/a&gt; operation on the elements of this stream. A mutable * reduction is one in which the reduced value is a mutable result container, * such as an {@code ArrayList}, and elements are incorporated by updating * the state of the result rather than by replacing the result. This * produces a result equivalent to:" />
      <item value="The {@code identity} value must be an identity for the combiner * function. This means that for all {@code u}, {@code combiner(identity, u)} * is equal to {@code u}. Additionally, the {@code combiner} function * must be compatible with the {@code accumulator} function; for all * {@code u} and {@code t}, the following must hold: * &lt;pre&gt;{@code * combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)" />
      <item value="but is not constrained to execute sequentially." />
      <item value="Performs a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt; on the * elements of this stream, using the provided identity, accumulation and * combining functions. This is equivalent to:" />
      <item value="The generator function takes an integer, which is the size of the * desired array, and produces an array of the desired size. This can be * concisely expressed with an array constructor reference:" />
      <item value="This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal * operation" />
      <item value="Returns an array containing the elements of this stream, using the * provided {@code generator} function to allocate the returned array, as * well as any additional arrays that might be required for a partitioned * execution or for resizing." />
      <item value="performing the action for subsequent elements, but for any given element, * the action may be performed in whatever thread the library chooses." />
      <item value="This operation processes the elements one at a time, in encounter * order if one exists. Performing the action for one element * &lt;a href=&quot;../concurrent/package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt;" />
      <item value="Performs an action for each element of this stream, in the encounter * order of the stream if the stream has a defined encounter order." />
      <item value="Returns a stream consisting of the remaining elements of this stream * after discarding the first {@code n} elements of the stream. * If this stream contains fewer than {@code n} elements then an * empty stream will be returned." />
      <item value="Returns a stream consisting of the elements of this stream, truncated * to be no longer than {@code maxSize} in length." />
      <item value="Returns a stream consisting of the elements of this stream, additionally * performing the provided action on each element as elements are consumed * from the resulting stream." />
      <item value="This is an &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;intermediate * operation" />
      <item value="For parallel stream pipelines, the action may be called at * whatever time and in whatever thread the element is made available by the * upstream operation. If the action modifies shared state, * it is responsible for providing the required synchronization." />
      <item value="Returns a stream consisting of the elements of this stream, sorted * according to natural order. If the elements of this stream are not * {@code Comparable}, a {@code java.lang.ClassCastException} may be thrown * when the terminal operation is executed." />
      <item value="Returns a stream consisting of the distinct elements (according to * {@link Object#equals(Object)}) of this stream." />
      <item value="Returns a stream consisting of the results of replacing each element of * this stream with the contents of a mapped stream produced by applying * the provided mapping function to each element. Each mapped stream is * {@link java.util.stream.BaseStream#close() closed} after its contents * have been placed into this stream. (If a mapped stream is {@code null} * an empty stream is used, instead.)" />
      <item value="the {@code Comparator} used to compare the sort key" />
      <item value="the function used to extract the sort key" />
      <item value="the function used to extract the {@link * Comparable} sort key" />
      <item value="Represents an operation that accepts an object-valued and a * {@code int}-valued argument, and returns no result. This is the * {@code (reference, int)} specialization of {@link BiConsumer}. * Unlike most other functional interfaces, {@code ObjIntConsumer} is * expected to operate via side-effects." />
      <item value="Represents an operation upon two operands of the same type, producing a result * of the same type as the operands. This is a specialization of * {@link BiFunction} for the case where the operands and the result are all of * the same type." />
      <item value="the initial element" />
      <item value="Type parameters of functional interfaces can be specialized to * primitives with additional type prefixes. To specialize the return type * for a type that has both generic return type and generic arguments, we * prefix {@code ToXxx}, as in {@link java.util.function.ToIntFunction}. * Otherwise, type arguments are specialized left-to-right, as in * {@link java.util.function.DoubleConsumer} * or {@link java.util.function.ObjIntConsumer}. * (The type prefix {@code Obj} is used to indicate that we don't want to * specialize this parameter, but want to move on to the next parameter, * as in {@link java.util.function.ObjIntConsumer}.) * These schemes can be combined, as in {@code IntToDoubleFunction}. * &lt;/li&gt;" />
      <item value="Binary Operator" />
      <item value="Represents an operation on a single operand that produces a result of the * same type as its operand. This is a specialization of {@code Function} for * the case where the operand and result are of the same type. *" />
      <item value="There are additional derived function shapes which extend the basic * function shapes, including {@link java.util.function.UnaryOperator} * (extends {@code Function}) and {@link java.util.function.BinaryOperator} * (extends {@code BiFunction})." />
      <item value="Unary Operator" />
      <item value="To Int Function" />
      <item value="&lt;li&gt;There are additional derived function shapes which extend the basic * function shapes, including {@link java.util.function.UnaryOperator} * (extends {@code Function}) and {@link java.util.function.BinaryOperator} * (extends {@code BiFunction}). * &lt;/li&gt;" />
      <item value="(binary function from {@code T} and" />
      <item value="nilary" />
      <item value="(nilary function to {@code R})." />
      <item value="(unary function from {@code T} to {@code boolean})," />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="472" />
        <entry key="ENGLISH" value="473" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="GALICIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CORSICAN" value="20" />
        <entry key="KURDISH" value="1" />
        <entry key="LATVIAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MALAGASY" value="3" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="JAPANESE" value="2" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="CEBUANO" value="1" />
        <entry key="GREEK" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>